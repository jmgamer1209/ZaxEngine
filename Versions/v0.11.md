## FrameBuffer帧缓冲 与 后处理

主要内容：
1. 创建自己的 Vector 和 Color 结构
2. 使用帧缓冲，简单的后处理

对于第1点，特别注意的是，IMGUI操作的是 float*，所以，需要把 Vector 和 Color 进行强转。为什么可以强转，因为C++中两者只要内存布局是一致的，那么 float* 和 其他类型就没什么区别，只是个内存的起始地址而已。

本来这一版本，想要做阴影的，但是阴影问题会牵扯到帧缓冲与立方体贴图，所以，这里先把帧缓冲熟悉下。

帧缓冲，就是渲染流水线最后保留下的数据，比如屏幕颜色，深度值，模板值。如果在渲染时，设置的缓冲是屏幕关联的帧缓冲，那么就会渲染到屏幕上，如果此缓冲不与屏幕关联，就是所谓的离屏渲染。

对于颜色值，使用纹理对象保存，而对于深度值和模板值，因为当前只需要写操作，所以直接使用渲染缓冲对象(Render Buffer Object)。

这个 RBO 也没什么特别的，就是一个原生的内存区域，不像纹理对象，有各种属性(比如Wrap/Filter)，它只是单纯的包含数据。

**也就是说，帧缓冲并不直接包含实际数据，是空的，而是通过关联这种纹理对象/渲染对象等缓冲对象，来间接保存数据。能够理解这点基本就差不多了。**

整个过程大致如下：
1. 生成FrameBuffer，并绑定纹理和渲染对象
2. 设置当前渲染的FrameBuffer，并执行渲染过程
3. 设置当前渲染的FrameBuffer为窗口的 FrameBuffer，只要绑定 0索引即可，然后对上述的 FrameBuffer 中关联的纹理执行后处理操作。


### 需要注意的点

当


**运行结果：**
![](../Versions/Assets/v0.11_result.png)
