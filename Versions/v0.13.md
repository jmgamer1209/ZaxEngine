## 阴影 ShadowMap

主要内容：
1. 深度可视化
2. 显示直射光阴影
2. 显示点光源阴影

因为阴影需要深度信息，所以，先将深度可视化，作为预备知识，为显示阴影做准备

### 深度可视化

在片元着色器中，从 gl_FragCoord.z 获取深度值。
```c
FragColor = vec4(vec3(1-pow(gl_FragCoord.z, 200)), 1.0);
```
首先通过 pow 函数，放大深度差，然后因为越靠近摄像机的深度越小，这样显示出来从近及远是黑色的，所以通过 1-x，进行反相，这样结果就是从近及远，由白变黑。

gl_FragCoord，xy 表示该片元屏幕窗口的位置，默认左下角为(0,0)。z表示深度值，范围为0-1，与右手坐标系不同，而是z朝前越大，属于左手坐标系。

我们知道，在顶点着色器中，返回的是一个边长为2的立方体空间，而坐标范围为(-1,1)，所以，在经过视口变换后，得到的屏幕坐标的z值，会被映射到(0,1)，这是个值得注意的点。

在投影矩阵中，有一件事没有说明，便是z轴的非线性变化，因为我们需要靠近摄像机的物体，精度更大，所以进行了非线性变换，这个可以看其他文章。

还有1个内置变量容易混淆，**gl_FragDepth**，这个表示可写入深度值，也即深度测试会使用的值，gl_FragCoord.z 跟这个的关系，如果没有特殊情况修改过gl_FragDepth值，gl_FragDepth 就会默认使用 gl_FragCoord.z，当然，这也是在片元处理之后了，如果在片元中对 gl_FragDepth 读取的话是结果总是0.

![](../Versions/Assets/v0.13_depth.png)

### 直射光阴影

阴影技术也称为ShadowMap，实现的基本思路比较简单，就是先从光源的视角，渲染一张深度图，然后在正式渲染场景时，将片元变换到光源的视角下，如果此片元深度值大，说明这个片元在阴影中。

思考一下，可不可以先渲染场景，再渲染光源深度图呢？可以这样，但是，这样的话，你就得到了一个已经着色后的片元，这样你的处理方式就非常受限制(只能是在阴影中和不在两种情况)，是不如先渲染深度图灵活的。

当使用平行光去阴影投射时，那么，需要从光源的角度构建 View 矩阵，这时光源的位置，作为一个平行光，正常来讲是不影响光照的，但是，这里，由于构建View以及正射投影矩阵，所以会影响到阴影，比如某个物体，可能在光源的后面，所以，实际生成矩阵时，我们不能采用光源的位置，而是根据整个场景去调整生成矩阵的这些参数。<br>
这部分内容，目前整个引擎框架还未搭建完成，所以暂时先放一下，先用 light 位置代替。

在解决阴影失真的过程中，自己犯了一个很严重的错误，就是在光视图的构造矩阵上，正射投影的大小，我最开始为了能够覆盖全场景，所以刻意设置了一个100单位的正方形大小，那么，导致的结果就是，同样的阴影图分辨率1024，如果是10单位，那么每个单位是100个像素，但是如果是100单位，每单位只有10像素，所以搞了两天，用了可尝试的方法，失真问题还是存在。<br>
在想到是大小设置的问题前，我确实没有想到正射投影的大小会如此影响阴影图，认为是越大越好。（问题的发现是不断地修改参数，然后又对比Untiy的阴影图，发现Untiy的阴影图很紧凑）

这部分核心有4个问题：
1. 坐标计算，主要是光栅化的前过程：裁剪、透视除法和视口变换
2. 阴影失真，这个是比较难理解的，从采样及结合
4. 阴影锯齿

在绘制ViewMode的深度图时，我们的帧缓冲，同时开启了颜色绘制和深度填充，这是为了对深度值做简单的显示处理。<br>
但在绘制阴影时，我们不需要做额外处理，所以要关闭 ShadowFrameBuffer 的颜色绘制，并将 Depth 绑定一个纹理，而不是RB，这样直接将深度值填充到纹理中。之前有个版本，我们说过帧缓冲必须要绑定颜色缓冲，在这里就不对了，其实是可以关闭的。那么，这个纹理就会只有 r 值会被写入深度值，所以读取时，只读取 r 值就可以了。（为什么Untiy还需要将深度值编码为RGBA呢？因为并不是所有渲染API都可以这样做，所以为了跨平台考虑进行了额外的编解码工作）


**坐标计算**

因为变量 fragPosInLight 并没有经过内部的光栅化前过程(裁剪、透视除法、视口变换)，所以这里需要自己计算。不过可以先进行除法和变换，再进行裁剪。(流程跟硬件层是不太一样的，因为我们不是要进行真正的裁剪，只是为了判断)

透视除法和视口变换的代码：

```c
vec3 fragScreenCoordInLight = (fragPosInLight.xyz / fragPosInLight.w).xyz * 0.5 + vec3(0.5);
```

进行了透视除法和视口变换，但有2个注意点：
* 第1点，我们仅把坐标映射到0-1而不用真的映射到屏幕分辨率，因为0-1是为了我们可以直接从 ShadowMap中采样，纹理的坐标范围是0-1
* 第2点，驱动的视口变换，会进行坐标系转换，但是我们并不需要，所以相比驱动的变换，我们少了这几个步骤，这个是需要了解的。


对于裁剪，产生的问题时，当场景很大时，如果场景受光的部分远大于光的阴影范围(就是投影矩阵窗口的大小和远近)，那么对于那些部分，当采样深度图时，会出现问题。所以需要做2个事情：
1. 把深度图的环绕方式改为 Clamp，并将深度图的 Border 设为1，这样如果横向超过范围，采样的深度就是1，表示阴影为0
2. 如果判断的顶点超过了光视图的最远处，那么，z 会大于1 (因为这个坐标没经过光视图下光栅化的裁剪过程)，所以当 z 大于 1 时，也要限制阴影为0

**阴影失真(Shadow Acne)**

如果只进行上面的处理，那么，你可能会得到下面的结果：
![](../Versions/Assets/v0.13_阴影失真.png)

图中平行光的朝向为朝前，同时箱子存在一定斜率，可以看到条纹现象。（上面的图片我通过其他光源加强了一下亮暗对比）

其失真的原理，主要在于深度图的分辨率，以及采样是离散采样:
![](../Versions/Assets/v0.13_阴影失真原理图.png)

绿色粗线表示需要渲染的片元在光视图下的位置，黑色粗线表示周围片元对应深度图的位置，假设有2个片元都去找同一个位置，那么很可能出现其中一个深度比该位置的深度小，另一个大的情况。

那么解决方案，最直观的方式，就是添加一个偏移，将所有片元在光视角下的深度，再减小一个偏移值，比如 0.005，这样就强行的将片元的深度值变小。

同时，根据光源方向和表面的倾斜程度不同，偏移值肯定也是不同的，这个画画图就清楚了。那么，可以简单使用下面的计算：
```c
// 最大值为 0.05，最小值为 0.005，夹角越大，偏移值就越小
float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);  
```

那么，如果偏移值设置过大，就会出现有些片元明明在就是在阴影中，但是因为偏移后更加靠前，导致本来在阴影的，却受到光照了，这种情况叫悬浮。

其中一种解决悬浮的方式，就是 **绘制阴影图时，使用正面剔除**，那么深度图里保存的，就是背面深度，对于闭合的物体来讲，在渲染场景的阶段，正面的顶点深度一定是远小于背面的，所以就算在有偏移的情况下，也不会出现悬浮了。<br>
但是因为如果采用正面剔除，就会导致薄物体不写入深度了，那么就不会记录深度图，这样问题会非常严重（Untiy中也是只用了偏移）。目前主流引擎，并没有采用这种方式。

**注意,在LearnOpenGL的评论里，有人说到正面剔除和偏移是都是都是解决失真的方式，这是理解方式的不同，因为如果只用正面剔除，那么，条纹现象是不会消失！所以，我理解上，正面剔除只是作为辅助存在的**

这种悬浮，在不同物体上，可能情况并没有那么严重，但是，对于自阴影，影响会非常大，比如：
![](../Versions/Assets/v0.13_自阴影悬浮.png)

这种结果我们肯定是不能接受的。所以，我们需要根据坡度，更加精确的控制偏移量，这种实现方式称为 Slope-Scale Depth Bias



**阴影锯齿**

PCF(percentage-closer filtering)，术语看起来比较高级，实际上就是个n*n的采样平均效果，这个很好理解。目前版本采用 3*3 采样。



### 点光源阴影


**运行结果：**
![](../Versions/Assets/v0.13_result.png)