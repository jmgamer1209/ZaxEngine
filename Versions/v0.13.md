## 阴影 ShadowMap

主要内容：
1. 深度可视化
2. 显示直射光阴影
2. 显示点光源阴影

因为阴影需要深度信息，所以，先将深度可视化，作为预备知识，为显示阴影做准备

### 深度可视化

在片元着色器中，从 gl_FragCoord.z 获取深度值。
```c
FragColor = vec4(vec3(1-pow(gl_FragCoord.z, 200)), 1.0);
```
首先通过 pow 函数，放大深度差，然后因为越靠近摄像机的深度越小，这样显示出来从近及远是黑色的，所以通过 1-x，进行反相，这样结果就是从近及远，由白变黑。

gl_FragCoord，xy 表示该片元屏幕窗口的位置，默认左下角为(0,0)。z表示深度值，范围为0-1，与右手坐标系不同，而是z朝前越大，属于左手坐标系。

我们知道，在顶点着色器中，返回的是一个边长为2的立方体空间，而坐标范围为(-1,1)，所以，在经过视口变换后，得到的屏幕坐标的z值，会被映射到(0,1)，这是个值得注意的点。

在投影矩阵中，有一件事没有说明，便是z轴的非线性变化，因为我们需要靠近摄像机的物体，精度更大，所以进行了非线性变换，这个可以看其他文章。

还有1个内置变量容易混淆，**gl_FragDepth**，这个表示可写入深度值，也即深度测试会使用的值，gl_FragCoord.z 跟这个的关系，如果没有特殊情况修改过gl_FragDepth值，gl_FragDepth 就会默认使用 gl_FragCoord.z，当然，这也是在片元处理之后了，如果在片元中对 gl_FragDepth 读取的话是结果总是0.

![](../Versions/Assets/v0.13_depth.png)

### 直射光阴影

这部分核心有4个问题：
1. 坐标计算，主要是光栅化的前过程：裁剪、透视除法和视口变换
2. 阴影失真，这个是稍微难理解点
3. 阴影锯齿

阴影技术也称为ShadowMap，实现的基本思路比较简单，就是先从光源的视角，渲染一张深度图，然后在正式渲染场景时，将片元变换到光源的视角下，如果此片元深度值大，说明这个片元在阴影中。

思考一下，可不可以先渲染场景，再渲染光源深度图呢？可以这样，但是，这样的话，你就得到了一个已经着色后的片元，这样你的处理方式就非常受限制(只能是在阴影中和不在两种情况)，是不如先渲染深度图灵活的。

在绘制ViewMode的深度图时，我们的帧缓冲，同时开启了颜色绘制和深度填充，这是为了对深度值做简单的显示处理。<br>
但在绘制阴影时，我们不需要做额外处理，所以要关闭 ShadowFrameBuffer 的颜色绘制，并将 Depth 绑定一个纹理，而不是RB，这样直接将深度值填充到纹理中。之前有个版本，我们说过帧缓冲必须要绑定颜色缓冲，在这里就不对了，其实是可以关闭的。那么，这个纹理就会只有 r 值会被写入深度值，所以读取时，只读取 r 值就可以了。（为什么Untiy还需要将深度值编码为RGBA呢？因为旧的API并支持深度纹理格式）

当使用平行光去阴影投射时，那么，需要从光源的角度构建 View 矩阵，这时光源的位置，作为一个平行光，正常来讲是不影响光照的，但是，这里，由于构建View以及正射投影矩阵，所以会影响到阴影，比如某个物体，可能在光源的后面，所以，实际生成矩阵时，我们不能采用光源的位置，而是根据整个场景去调整生成矩阵的这些参数。<br>
这部分内容，目前整个引擎框架还未搭建完成，所以暂时先放一下，先用 light 位置代替。

在解决阴影失真的过程中，自己犯了2个很严重的错误，导致了浪费了大量时间
1. 在光视图的构造矩阵上，正射投影的大小，我最开始为了能够覆盖全场景，所以刻意设置了一个100单位的正方形大小，那么，导致的结果就是，同样的阴影图分辨率1024，如果是10单位，那么每个单位是100个像素，但是如果是100单位，每单位只有10像素，所以搞了两天，用了可尝试的方法，失真问题还是存在。<br>
在想到是大小设置的问题前，我确实没有想到正射投影的大小会如此影响阴影图，认为是越大越好。（问题的发现是不断地修改参数，然后又对比Untiy的阴影图，发现Untiy的阴影图很紧凑）
2. 在构造正交投影矩阵时，将top和bottom的正负写反了，真是蠢哭了，导致了无论怎么调，都达不到效果，后来从 renderdoc 的深度图里找到点蛛丝马迹，发现深度图渲染错误，最后发现是参数写错了，这里几乎也浪费了快两天，不过因为这个，我也好好的了解了更多阴影相关的知识点。


**坐标计算**

因为变量 fragPosInLight 并没有经过内部的光栅化前过程(裁剪、透视除法、视口变换)，所以这里需要自己计算。不过可以先进行除法和变换，再进行裁剪。(流程跟硬件层是不太一样的，因为我们不是要进行真正的裁剪，只是为了判断)

透视除法和视口变换的代码：

```c
vec3 fragScreenCoordInLight = (fragPosInLight.xyz / fragPosInLight.w).xyz * 0.5 + vec3(0.5);
```

进行了透视除法和视口变换，但有2个注意点：
* 第1点，我们仅把坐标映射到0-1而不用真的映射到屏幕分辨率，因为0-1是为了我们可以直接从 ShadowMap中采样，纹理的坐标范围是0-1
* 第2点，驱动的视口变换，会进行坐标系转换，但是我们并不需要，所以相比驱动的变换，我们少了这几个步骤，这个是需要了解的。


对于裁剪，产生的问题时，当场景很大时，如果场景受光的部分远大于光的阴影范围(就是投影矩阵窗口的大小和远近)，那么对于那些部分，当采样深度图时，会出现问题。所以需要做2个事情：
1. 把深度图的环绕方式改为 Clamp，并将深度图的 Border 设为1，这样如果横向超过范围，采样的深度就是1，表示阴影为0
2. 如果判断的顶点超过了光视图的最远处，那么，z 会大于1 (因为这个坐标没经过光视图下光栅化的裁剪过程)，所以当 z 大于 1 时，也要限制阴影为0

**阴影失真(Shadow Acne)**

如果只进行上面的处理，那么，你可能会得到下面的结果：
![](../Versions/Assets/v0.13_阴影失真.png)

图中平行光的朝向为朝前，同时箱子存在一定斜率，可以看到条纹现象。（上面的图片我通过其他光源加强了一下亮暗对比）

其失真的原理，主要在于深度图的分辨率，以及采样是离散采样:
![](../Versions/Assets/v0.13_阴影失真原理图.png)

绿色粗线表示需要渲染的片元在光视图下的位置，黑色粗线表示周围片元对应深度图的位置，假设有2个片元都去找同一个位置，那么很可能出现其中一个深度比该位置的深度小，另一个大的情况。

那么解决方案，最直观的方式，就是添加一个偏移，将所有片元在光视角下的深度，再减小一个偏移值，比如 0.005，这样就强行的将片元的深度值变小。

那么，根据图示，可以知道，不同的倾斜角，有不同的偏移值，具体要添加多大的偏移呢？要解决阴影失真，必须要理解 shadow bias 数值的精确计算方法，其实不难，就是一丢丢三角函数关系。[具体计算可以查看这篇文章](https://zhuanlan.zhihu.com/p/370951892)。

对于偏移的方案，有2个方案，或者结合
* Depth Bias，也称为 Slope-Scale Depth Bias，沿光线方向偏移
* Normal Bias，沿法线方向偏移

这两种偏移方式，都存在一定的问题，但是可以结合两者，去做一个比较平衡的效果(Unity中已经实现了两种方案)。这个版本暂时只用 Depth Bias。

顺便提一下，只要是偏移，那么不免就会存在悬浮或者透光的情况，无论哪种方式。其中一种解决悬浮的方式，就是 **绘制阴影图时，使用正面剔除**，那么深度图里保存的，就是背面深度，对于闭合的物体来讲，在渲染场景的阶段，正面的顶点深度一定是远小于背面的，所以就算在有偏移的情况下，也不会出现悬浮了。<br>
但是采用正面剔除后，就会导致薄物体不写入深度，那么就不会记录到深度图，这样问题会非常严重，当下的主流引擎，也都没有采用这种方式。因为大部分情况下，设置一个偏移，已经完全满足需求了。

**注意,在LearnOpenGL的评论里，有人说到正面剔除和偏移是都是都是解决失真的方式，这是理解方式的不同，因为如果只用正面剔除，那么，在某些角度下条纹现象还是会特别明显。所以，我理解上，正面剔除只是作为辅助存在的**

最终计算，我采用了参考链接里的 cos 拟合做法，并没有采用 LearnOpenGL 中的方式，因为我的箱子存在内部凹陷，所以需要准确的每像素有多少单位，如果用LearnOpenGL的计算，箱子的自阴影问题会非常大。
```glsl
    float a = frustumSize / shadowSize * 0.5;
    float b = 1.0 - dot(normal, lightDirection);
    float bias = max(depthBias * a * b, 0.005); // 限制最小值，depthBias 为可调节值，可为 0.5
```

**阴影锯齿**

这里只使用1种抗锯齿方案：PCF，类似于 MSAA

PCF(percentage-closer filtering)，术语看起来比较高级，实际上就是个n*n的采样平均效果，这个很好理解。目前版本采用 3*3 采样。


### 点光源阴影


**运行结果：**
![](../Versions/Assets/v0.13_result.png)