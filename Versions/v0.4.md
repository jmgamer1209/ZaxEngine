将纹理绘制到四边形。

主要知识点：

* 图像加载库 stb_image
* 纹理的基础知识：纹理坐标，环绕方式，纹理过滤,Mipmap
* 纹理采样器的使用

### 图像的加载

图片加载到内存中，是以 Bitmap 格式，也就是位图格式存储的，stb_image 就是用来把各种压缩格式的图片，转换为位图。

那么，图片加载到内存里，实际占用多大的内存呢？

因为是位图，所以占用的大小只跟系统设备对于该位图的存储有关，与图片本身的格式是无关的。

### 纹理的基础知识

纹理的坐标系统叫做ST坐标系统，和xy坐标系统一样，s对应x，t对应y

纹理环绕方式，GL_TEXTURE_WRAP_S 和 GL_TEXTURE_WRAP_T 表示超出某个坐标范围时的纹理处理方式，可以设置的值如下：GL_CLAMP_TO_EDGE、GL_REPEAT、GL_MIRRORED_REPEAT

纹理过滤方式，可以设置纹理在缩小时和放大时的过滤方式，可设置为 Nearest（邻近过滤），Liner（线性过滤），双线性（Bilinear），三线性

Mipmap，主要是为了解决远处物体纹理采用问题，这个版本其实没什么用，可以先了解。

图片资源的原点在左上角，而 OpenGL 中的纹理坐标是以左下角为 (0,0) 点，那么加载图片时，需要上下反转一下数据流，stb_image 提供了这个功能。

### 代码编写上的细节

由于纹理的绑定不会记录在VAO里，所以每次都有重新绑定，并且需要先激活，在绑定
```c++
	glActiveTexture(GL_TEXTURE0);          //激活纹理单元
	glBindTexture(GL_TEXTURE_2D, texture); // 绑定
    shaderProgram->SetUniform("texture1", 0); // 设置
```

**激活纹理单元**是什么意思呢？为什么这个是 GL_TEXTURE0，后边跟着一个序号？<br>
这是根据GPU硬件设计来的，如果看英伟达的硬件图，就知道GPU硬件中，专门有个区域，存储纹理，并且这个区域有数量的限制，一般来说至少会有16个<br>
我猜测，当激活纹理单元，再执行绑定操作后，那么这个纹理的数据会提交到这个专门的纹理区域。而 Shader 也从这个专门的区域去采样。


**运行结果：**
![](../Versions/Assets/v0.4_result.png)
